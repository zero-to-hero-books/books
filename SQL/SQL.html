<html><head>
    <meta charset="UTF-8">

    <style>

        i, code{ font-family: monospace;}

        code b{color: #00e;}
        img{display:block; margin:0 auto; max-width:80%;}
		
		.output{margin-top:0.5em;}
		.tbl{border-width: 1px; border-style:solid;}
		.tbl td{border-width: 1px; border-style:solid; padding:0.5em;}
		.output th, .sql th{text-align:left;}
		.output tr:nth-child(even){background: #eee;}
		h1,h2,h3,h4,h5,h6{page-break-after: avoid;}
		body{line-height: 1.5em;}
	    	.btn{border: 1px solid; border-radius:3px; cursor:default; height: 2em; line-height: 2em; 
			border-color: rgba(52, 85, 120, 0.3) rgba(52, 85, 120, 0.3) rgba(52, 85, 120, 0.5) rgba(52, 85, 120, 0.5); 
			background:linear-gradient(to bottom, #F6F6F6 0%, #E6E6E6 100%);
			box-shadow: 0px 1px 0px rgba(255, 255, 255, 0.2) inset, 0px 1px 2px rgba(0, 0, 0, 0.05);
		}
		.btn.amazon{background: linear-gradient(to bottom,#f7dfa5 0%,#f0c14b 100%)}
		.btn.amazon:hover{background: linear-gradient(to bottom,#f7dfa5 0%,#fdd15b 100%)}
		a.btn{display:inline-block; text-decoration:none; color:black; padding:0 0.5em;}
    </style>
</head>

<body>
    <section style="text-align:center;">
        <div style="font-size: xx-large;">Zero-to-Hero:<br><br>SQL</div><br><br><br><br><div style="font-size: x-large;">Adam McAllister</div>
            <br><br><br><br>
    	<p>Copyright Â© 2020 Andras T. Papp<br>
            ISBN-10: 1652710019<br>
            ISBN-13: 978-1652710011
    	</p>
        <p>Printed copies of the book can be purchased on Amazon:<br>https://www.amazon.com/dp/1652710019
	    <br><a href="https://www.amazon.com/dp/1652710019" traget="_blank" class="btn amazon">Buy on Amazon</a></p>
        
    </section>
    <!-- Introduction -->
    <section>
        <h1 class="nocount">Introduction</h1>
	    <p>This book is intended to be concise and to the point. The Structured Query Language (SQL) is fairly straight forward. At the same time, seemingly simple search queries can be difficult to formulate in terms of SQL. It is not enough to read about the language, it has to be practiced so that you start thinking in the structure of SQL. It is important to try the examples in the book. Results of SQL statements can be more readily grasped when the entirety of the dataset can be conceptualized. Moreover, the relational aspect of databases are more easily understood when you have to create the linkages between tables and data yourself. To that end, the examples in the book are run on a small set of data using SQLite. Everything is done from scratch including table creation and data entry.</p>
        <p>All resources needed for this book are freely available on the internet. You can download SQLite from its website: https://sqlite.org/download.html
    </p>
        <p>
            Download the file for your platform that begins with <i>sqlite-tools-</i>, as that includes a shell program that does not require installation. On Windows after unzipping the file you can just double-click on <i>sqlite3.exe</i> and it will bring up the SQLite shell.</p>
        <img src="./shell.png">
        <p>
            The website for the book also contains a web version of SQLite with a built in database that contains all the tables and data used in the book: https://zero-to-hero-books.github.io/books/<br>
			This SQL prompt is a full featured web version SQLite compiled to asm.js. You can run the code in the book and experiment with SQL without having to install any database software. Note that changes to the tables will not be saved. Reloading the page reloads the original tables from Chapter 2.</p>
        <img src="./websqlite.png">

        <p>As the title of the book states, we will be starting from absolute zero. If you are just starting to learn SQL, then this book is for you. However, even if you are familiar with SQL I would still recommend reading the book from start to finish. Most books and tutorials start with searching for a specific set of records in a table, and then try to tack on querying multiple tables. That is not "thinking in terms of SQL." In relational databases information is divided into tables to reduce duplicate / redundant data. Hence, querying a database almost always involves data from multiple connected tables. How to connect / join tables when querying is introduced as early on as possible, and most of the examples in the book use multiple tables at a time. The chapters are meant to be read sequentially, and each chapter builds on the previous.</p>
        <p>This book is meant to teach the SQL language and its usage from the end user perspective. Aspects of SQL that facilitate database administration and security such as access controls, roles, views, stored procedures and triggers are not covered.</p>
    </section>

    <!-- 1. What is a relational database, what is SQL? -->
    <section>
        <h1>1. What is a relational database, what is SQL?</h1>
        <p>Consider a global bank with ten million accounts with five transactions per account per day on average. That is 50 million transactions records per day. In addition to the transactions table the account balance table has to be updated as well as the loan table, the mortgage table, the credit card table and so forth. All of the data tables are linked in one way or another. This data not only has to be stored, it has to be searchable and both storage and query operations have to be fast. Accountants have to query and summarize all of this data, while fraud investigators have to be able to process this data to find possible patterns that may indicate fraud. Clearly, a spreadsheet won't cut it. Database Management Systems (DBMS) are optimized to store, update and search large amounts of data. SQL, the Structured Query Language, is a standardized method of interacting with the databases of various DBMS vendors. While not all databases support every aspect of SQL, the core features of the language are supported by all vendors. Moreover, DBMS vendors implement functions and extensions that are unique to their product. In this book we will cover the core SQL that is support by all databases. Once you have a proper foundation in SQL and how to use it, you can read up on the additional functions and features that your specific database offers.</p>
        <p>Databases aren't just for banks or extremely large amounts of data; they are useful for analysis of any set of data tables that have relational data, regardless of size. Let's look at how a spreadsheet program stores data and compare it to a relational database. In a spreadsheet program multiple spreadsheets are part of a workbook. The spreadsheets contain the tabular data and can contain references to other spreadsheets in the workbook. The workbook itself does not contain data, it contains the spreadsheets with the data. Similarly, a database contains tables, which contain the tabular data. These tables will have columns that link one table to another, thereby defining a relationship between the data.</p>
        <p>In a spreadsheet we specify exactly which row and column a value should be stored in. However, we do not know how a database internally organizes the storage of data. It is more than likely that the order in which we enter records is not the order that they will be stored in. While a spreadsheet considers each field independent and identifies fields using a row / column index, a database treats a row of data as a single record. When we insert data into a database table we don't insert fields, rather we insert (or update) an entire row. When we retrieve the data we don't specify the row / column index, instead we submit a query to the database which returns a set of records. Database tables do contain an index which uniquely identifies a record, called the primary key. Thus, individual records can be retrieved. However, the key feature of databases is the ability to run complex search queries.</p>
        <p>A spreadsheet allows you to enter any kind of data into any field, and the program determines the type of data based on the content. A column in a spreadsheet can contain text in one row and a number in another. In databases the type of data that a column contains is defined when the table is created. If a column is to contain only numbers, for example, and the data type of the column is defined as an integer, then the database will only accept integer numbers in that column. While a spreadsheet is a collection of cells / fields, a database should be thought of as columns of data.
        </p>
        <ul>
            <li>Databases contain tables of data with predefined relationships between the tabular data columns.</li>
            <li>Tables consist of columns that restrict the type of data that they can contain.</li>
            <li>Fields / values in a database should not be thought of as stand alone units of data. Each record is an entire row of data corresponding to the columns in the database.</li>
            <li>SQL is a set of statements consisting of predefined keywords. An SQL statement will return a set of data for a query, or update / change the data in the database.</li>
        </ul>

    </section>

    <!-- 2. Creating tables and indexes, adding data -->
    <section>
        <h1>2. Creating tables and indexes, adding data</h1>
        <p>To demonstrate the usage of SQL we will be creating a database for a library borrowing system. This database will only contain a small number or records, specifically the following 12 books: </p>
        <ol>
            <li>Pride and Prejudice by <b>Jane Austen</b>, ISBN: 0141439513</li>
            <li>Alice's Adventures in Wonderland by <b>Lewis Carroll</b>, ISBN: 0147515874</li>
            <li>The Adventures of Sherlock Holmes by <b>Arthur Conan Doyle</b>, ISBN: 3958700152</li>
            <li>A Study in Scarlet by <b>Arthur Conan Doyle</b>, ISBN: 1514698854</li>
            <li>The Sign of the Four by <b>Arthur Conan Doyle</b>, ISBN: 1523855789</li>
            <li>The Lost World by <b>Arthur Conan Doyle</b>, ISBN: 1945644621</li>
            <li>A Tale of Two Cities by <b>Charles Dickens</b>, ISBN: 0486406510</li>
            <li>Dracula by <b>Bram Stoker</b>, ISBN: 0486454016</li>
            <li>The Adventures of Tom Sawyer by <b>Mark Twain</b>, ISBN: 1976319161</li>
            <li>The Prince and the Pauper by <b>Mark Twain</b>, ISBN: 0199539278</li>
            <li>Adventures of Huckleberry Finn by <b>Mark Twain</b>, ISBN: 0486280615</li>
            <li>The Strange Case of Dr. Jekyll and Mr. Hyde by <b>Robert Louis Stevenson</b>, ISBN: 0199536228</li>
        </ol>
        <p>We interact with a database by submitting statements to the Database Management System. Before we can create tables to store our data, we need a database. (The introduction of the book has details on where to download the SQLite shell.) To create the database use the <code><b>.<b>open</b></b></code> command at the SQLite prompt: <code>.<b>open</b> library.db</code></p>
        <img src="./opendb.png">
        <p>Note that the open command is not an SQL statement, it is a command for the SQLite shell program. It opens the database file named <code>library.db</code>. If the <code>library.db</code> file does not exist, then it is created. You might want to use a full pathname to ensure that the file is in the directory that you want it created in. Use forward-slashes as the directory separator character. For example, use <code>C:/work/library.db</code>, instead of <code>C:\work\library.db</code>.</p>
        <p>If you are using the web version on the books website, https://zero-to-hero-books.github.io/books/, then the built-in database already contains all the tables and data used in the book.</p>
        <p>Our database will need four tables. There will need to be a table for the catalog of books. We want to avoid repeating the names of the authors over and over in the books table, so we will create a separate table to store the data on authors, assigning a unique ID for each author. Since our table of books will reference the author IDs in the authors table, we will need to create the table of authors first. Our library will need a table for membership, as well as a table to store the data on which books have been borrowed and by whom. Since the table that contains the data for checked out books will need to reference both the table of books and the table of membership, it will have to be created last.</p>
        <h2>Authors table</h2>
        <p>Now that we have our database we can create our tables using the <code><b>create</b> <b>table</b></code> SQL statement. The books in our library catalog will be stored in the <code>Books</code> table. As you can see above the data has multiple books from the same author. To avoid data entry errors and to facilitate search based on author name, we are going to create a table to store authors separately from the table of books. While our dataset does not contain different authors with the same name, a large collection of books probably will. The <code>Authors</code> table would be used to store additional information, such as authorsâ date of birth, without having to duplicate the data in the books table. </p>
        <table class="tbl">
            <thead>
                <tr>
                    <th>Authors</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>id (integer)</td>
                </tr>
                <tr>
                    <td>surname (text)</td>
                </tr>
                <tr>
                    <td>givennames (text)</td>
                </tr>
            </tbody>
        </table>
        <p>The SQL statement syntax consists of the <code><b>create</b> <b>table</b></code> keywords, followed by the table name, followed by the list of column definitions in parentheses. Column definitions are separated by commas:</p>
<table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>table</b> Authors(</code></td></tr><tr><td><code>id integer <b>primary</b> <b>key</b> <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>surname text <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>givennames text</code></td></tr><tr><td><code>);</code></td></tr></tbody></table>
        <p>SQL statements are not case sensitive, but table and column names are. SQL treats line breaks as any other whitespace. The end of the statement is the semi-colon. Thus, you can format statements to aid readability. The above SQL statement created the table <code>Authors</code> with three columns: <code>id</code>, <code>surname</code> and <code>givennames</code>. Each column is defined by the column name, followed by the data type and additional options. The data type for <code>id</code> is set as an integer number, while both the <code>surname</code> and <code>givennames</code> columns are text.</p>
        <p>Both the <code>id</code> and the <code>surname</code> column have the <code><b>not</b> <b>null</b></code> combination of keywords. This means that when we add a record to the <code>Authors</code> table it must have an ID number and must have a surname. The <code>givennames</code> column on the other hand does not have to contain a value. For example, Plato or Socrates would have a surname, but a <code><b>null</b></code> for <code>givennames</code>. Note that <code><b>null</b></code> is the complete absence of a value. It is not the same as an empty/zero length text.</p>
        <p>The index for a table that uniquely identifies records is called the primary key. In the <code>Authors</code> table we declared the <code>id</code> column as the primary key column using the <code><b>primary</b> <b>key</b></code> combination of keywords. Unlike most programming languages SQL looks very much like free flowing English, but the order and combination of keywords matters. You can switch up <code><b>primary</b> <b>key</b></code> and <code><b>not</b> <b>null</b></code>, but the column definition must begin with the column name and must be followed by the data type. </p>
        <p>Now that we have our <code>Authors</code> table let's proceed and enter the data. The primary key column has to contain unique integer numbers, so we will make up IDs for the authors as we enter the data. To add a record to a table we use the <code><b>insert</b> <b>into</b></code> statement, which is followed by the table name, the <code><b>values</b></code> keyword and the list of values for each column in the database, separated by commas:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Authors <b>values</b>(1, 'Jane', 'Austen');</code></td></tr></tbody></table>
        <p>Press enter to execute the statement and insert the next record:</p>
<table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Authors <b>values</b>(1, 'Caroll', 'Lewis');</code></td></tr></tbody></table>
<table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Error: UNIQUE constraint failed: Authors.id</td></tr></tbody></table>
<p>The <code>Authors.id</code> column is the primary key column of the table. It must have a unique value. Let's try again, this time with a unique value for the <code>id</code> column.</p>
<table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Authors <b>values</b>(2, 'Caroll', 'Lewis');</code></td></tr></tbody></table>
        <p>Note that text has to be between either single quotes or double quotes. Also note that we made an error. When creating the table the order of the columns was <code>id</code>, <code>surname</code> and then <code>givennames</code>. The <code><b>insert</b> <b>into</b></code> statement adds data in the order that it appears. Thus, "Jane" went into the <code>surname</code> column, while "Austen" was added to the <code>givennames</code> column. We have two options at this point, we can either delete the record and <code><b>insert</b> <b>into</b></code> the table again, or we can update the record. Let's update the record using the <code><b>update</b></code> statement. It consists of the <code><b>update</b></code> keyword, followed by the table name and the <code><b>set</b></code> clause. The <code><b>set</b></code> clause specifies which columns to change, and to what values:</p>
<table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>update</b> Authors </code></td></tr><tr><td><code><b>set</b> surname='Austen', givennames='Jane';</code></td></tr></tbody></table>
        <p>Notice how column / value pairs are separated by a comma. Did you try it? You should, databases do not have an undo button; it is better to experiment now and make mistakes on this example data set then to permanently overwrite every value in a production database.</p>
        <p>A relational database is a collection of columns, and SQL statements operate on columns. Letâs see what the <code><b>update</b></code> statement did. Type in the following statement to query all columns in the table (the statement will be explained in the next chapter.)</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> * <b>from</b> Authors;</code></td></tr></tbody></table>
<table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>1|Austen|Jane</td></tr><tr><td>2|Austen|Jane</td></tr></tbody></table>
        <p>If the <code><b>update</b></code> statement does not have a <code><b>where</b></code> clause, all rows in the table are modified by the update. Otherwise, the update affects only those rows for which the <code><b>where</b></code> clause is true. Letâs update the record with <code>id=2</code> so that it is "Lewis Caroll" again:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>update</b> Authors </code></td></tr><tr><td><code><b>set</b> surname='Caroll', givennames='Lewis'</code></td></tr><tr><td><code><b>where</b> id=2;</code></td></tr><tr><td><code></code></td></tr></tbody></table>
        <p>To minimize data entry errors it is good practice to always specify the columns for the data in the <code><b>insert</b> <b>into</b></code> statement. Column names can be specified after the table name in parentheses. They don't have to be in the same order as in the create table statement. Data in the values list will be inserted in the same order that the columns are specified in. Let's complete the data entry for our <code>Authors</code> table:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Authors(id, givennames, surname) <b>values</b>(3, 'Arthur Conan', 'Doyle');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Authors(id, givennames, surname) <b>values</b>(4, 'Charles', 'Dickens');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Authors(id, givennames, surname) <b>values</b>(5, 'Bram', 'Stoker');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Authors(id, givennames, surname) <b>values</b>(6, 'Mark', 'Twain');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Authors(id, givennames, surname) <b>values</b>(7, 'Robert Louis', 'Stevenson');</code></td></tr></tbody></table>
        <p>To demonstrate the <code><b>delete</b></code> statement let's <code><b>insert</b> <b>into</b></code> the <code>Authors</code> table two records with no <code>givennames</code>:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Authors(id, surname) <b>values</b>(8, 'Plato');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Authors(id, surname) <b>values</b>(9, 'Socrates');</code></td></tr><tr><td><code></code></td></tr></tbody></table>
        <p>The above <code><b>insert</b> <b>into</b></code> statement is allowed by the database, because the <code>givennames</code> column was not explicitly specified as <code><b>not</b> <b>null</b></code>. We can check the results with:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> * <b>from</b> Authors;</code></td></tr></tbody></table>
        <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>1|Austen|Jane</td></tr><tr><td>2|Caroll|Lewis</td></tr><tr><td>3|Doyle|Arthur Conan</td></tr><tr><td>4|Dickens|Charles</td></tr><tr><td>5|Stoker|Bram</td></tr><tr><td>6|Twain|Mark</td></tr><tr><td>7|Stevenson|Robert Louis</td></tr><tr><td>8|Plato|</td></tr><tr><td>9|Socrates|</td></tr></tbody></table>
        <p>We will now delete the two extra rows using the <code><b>delete</b> <b>from</b></code> statement. We could delete them individually using the <code>id</code>:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>delete</b> <b>from</b> Authors <b>where</b> id=8;</code></td></tr><tr><td><code><b>delete</b> <b>from</b> Authors <b>where</b> id=9;</code></td></tr></tbody></table>
        <p>Alternatively, we could delete from the table based on the surname values:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>delete</b> <b>from</b> Authors <b>where</b> surname='Plato';</code></td></tr><tr><td><code><b>delete</b> <b>from</b> Authors <b>where</b> surname='Socrates';</code></td></tr></tbody></table>
        <p>However, what we really want is to <code><b>delete</b> <b>from</b></code> the table all records where there is no value for the <code>givennames</code> column:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>delete</b> <b>from</b> Authors <b>where</b> givennames <b>is</b> <b>null</b>;</code></td></tr></tbody></table>
        <p>Notice how when working with values we use the equals sign to check equality, regardless of whether we are comparing numbers or text. However, when working with <code><b>null</b></code> we use the <code><b>is</b></code> and the <code><b>not</b></code> operators. <code>Null</code> means the absence of a value. For example, if we wanted to delete all records where the <code>givennames</code> column has a value, we would use:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>delete</b> <b>from</b> Authors <b>where</b> givennames <b>is</b> <b>not</b> <b>null</b>;</code></td></tr></tbody></table>
        <p>If you try the above statement then you will have to <code><b>insert</b> <b>into</b></code> the table all records again.</p>
        <p>Now that we have our <code>Authors</code> table the database can retrieve author names based on <code>id</code> very quickly, because the table is sorted by primary key. However, if we wish to search for authors based on the surname, given names or both, then the database will have to compare every single record in the table to the search criteria. Databases are very fast, so this will not result in a noticeable difference for a library of physical books. However, for a digital library that contains not just books, but say the library of congress and scientific journals of every discipline, comparing every record will be inefficient. Sorting the entries based on the primary key alone is not enough. We need to have the authors sorted by either <code>surname</code>, or both the <code>surname</code> and <code>givennames</code>. This can be done using an index. A table index maintains a sort order based on column(s) other than the primary key column. (Tables are always sorted based on the primary key column.) The <code><b>create</b> <b>index</b></code> statement looks similar to the <code><b>create</b> <b>table</b></code> statement. After the <code><b>create</b> <b>index</b></code> keywords comes the index name, followed by the <code><b>on</b></code> keyword, followed by the table name for which the index is to be created. The columns that the index should be sorted on are listed in parentheses after the table name. You can have an index sorted on one column or a combination of columns, separated by commas. Letâs create the index:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>index</b> Authorname <b>on</b> Authors(surname, givennames);</code></td></tr></tbody></table>
        <h2>Books table</h2>
        <table class="tbl">
            <thead>
                <tr>
                    <th>Books</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>isbn (text)</td>
                </tr>
                <tr>
                    <td>title (text)</td>
                </tr>
                <tr>
                    <td>authorid (integer)</td>
                </tr>
                <tr>
                    <td>count (integer)</td>
                </tr>
            </tbody>

        </table>
        <p>Now that we have our <code>Authors</code> table we can create our <code>Books</code> table. The primary key for the <code>Books</code> table will be the books' ISBN. The International Standard Book Number (ISBN) is a numeric commercial book identifier which is unique. Since some ISBN numbers start with zero we will have to create the ISBN column as a text column. If we created it as an integer column it would remove any leading zeros. Our table will need the book titles, the number of copies of the book that the library has, as well as the author IDs from the <code>Authors</code> table. It is possible to have two different ISBNs for the same title from the same author. ISBNs are linked to a publisher and historically paperbacks and hardbacks were issued by different publishers. However, in our example library we will require that each book have a unique title. This is accomplished with the <code><b>unique</b></code> keyword. Thus, two books with the same title cannot be included, even if they have different ISBNs. </p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>table</b> Books(</code></td></tr><tr><td><code>isbn text <b>primary</b> <b>key</b> <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>title text <b>not</b> <b>null</b> <b>unique</b> <b>collate</b> nocase,</code></td></tr><tr><td><code>authorid integer <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>count integer <b>default</b> 1 <b>check</b>(count &gt; 0),</code></td></tr><tr><td><code><b>foreign</b> <b>key</b>(authorid) <b>references</b> Authors(id)</code></td></tr><tr><td><code>);</code></td></tr></tbody></table>
        <p>In addition to the <code><b>unique</b></code> constraint the <code>title</code> column also has the <code><b>collate</b> nocase</code> combination of keywords. This ensures that sorting and comparisons on the column are case insensitive. (Collation, which just means sort order, is quite an involved topic and databases support a variety of collation options based on language and locale. The collation names differ between database vendors unfortunately. The <code>nocase</code> collation name is specific to SQLite.)</p>
        <p>For our database to work as intended there must be referential integrity between the <code>Authors</code> table and the <code>Books</code> table, which means that the author IDs in the <code>Books</code> table must be restricted to values that are in the <code>Authors</code> table. This is achieved with a foreign key. A foreign key in one table refers to a primary key in another. Some databases include the foreign key constraint with the column definition the same way as you would the primary key, while others (including SQLite) require that the constraint definition be specified after the columns. The syntax for foreign keys differs slightly between databases, but the concept is exactly the same. Above we specified that the <code>authorid</code> column must reference a value in the <code>id</code> column of the <code>Authors</code> table by placing the foreign key constraint after the column definitions:<br>
        <code><b>foreign</b> <b>key</b>(authorid) <b>references</b> Authors(id)</code></p>
        <p>Just as tables have names and indexes have names, constraints can also be named. This allows for altering or removing the constraint by name after table creation. A named constraint is created using the <code><b>constraint</b></code> keyword, followed by the name of the constraint, followed by the constraint definition as before. For example, if we wanted to name the foreign key constraint <code>authoreid_key</code>, then we would use the following syntax:<br>
        <code><b>constraint</b> authoreid_key <b>foreign</b> <b>key</b> (authorid) <b>references</b> Authors(id)</code></p>
        <p>The <code>count</code> column contains the number of copies that the library has. Instead of creating the column with the <code><b>not</b> <b>null</b></code> keywords, we specified a default value with the <code><b>default</b></code> keyword. Our library will have one copy of most books, so unless there are multiple copies a book's data can be inserted into the table without having to specify the copy count. Also notice that we included something called a check constraint. Each time we insert or update a record in the <code>Books</code> table the database will check to make sure that the <code>count</code> value is greater than zero. Just like the foreign key constraint check constraints can be included after the column definitions as well. We could have written the above <code><b>create</b> <b>table</b></code> statement as follows:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>table</b> Books(</code></td></tr><tr><td><code>isbn text <b>primary</b> <b>key</b> <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>title text <b>not</b> <b>null</b> <b>unique</b> <b>collate</b> nocase,</code></td></tr><tr><td><code>authorid integer <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>count integer <b>default</b> 1,</code></td></tr><tr><td><code><b>foreign</b> <b>key</b>(authorid) <b>references</b> Authors(id),</code></td></tr><tr><td><code><b>check</b>(count &gt; 0)</code></td></tr><tr><td><code>);</code></td></tr></tbody></table>
        <p>The <code><b>constraint</b></code> keyword can also be used in the column definitions to specify names for constraints. For example, we could name our check constraint as <code>count_chk</code>, the unique constraint as <code>title_unique</code> and the default constraint as <code>count_def</code> as follows:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>table</b> Books(</code></td></tr><tr><td><code>isbn text <b>primary</b> <b>key</b> <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>title text <b>not</b> <b>null</b> <b>constraint</b> title_unique <b>unique</b> <b>collate</b> nocase,</code></td></tr><tr><td><code>authorid integer <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>count integer <b>constraint</b> count_def <b>default</b> 1 <b>constraint</b> count_chk <b>check</b>(count &gt; 0),</code></td></tr><tr><td><code><b>foreign</b> <b>key</b> (authorid) <b>references</b> Authors(id)</code></td></tr><tr><td><code>);</code></td></tr></tbody></table>
        <p>Now that we have our <code>Books</code> table set up, let's populate it with our list of books. Note that for the second statment below we need to double up the single quotation mark, otherwise the database would think that the text ends at "Alice" instead of the full title. Alternatively we could use double quotes, e.g.: "Alice's Adventures in Wonderland." For most of the books we left out the <code>count</code> column, which means that the count will be the default value of 1 specified in the <code><b>create</b> <b>table</b></code> statement.</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn, count) <b>values</b>('Pride and Prejudice', 1, '0141439513', 2);</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('Alice''s Adventures in Wonderland', 2, '0147515874');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn, count) <b>values</b>('The Adventures of Sherlock Holmes', 3, '3958700152', 3);</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('A Study in Scarlet', 3, '1514698854');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('The Sign of the Four', 3, '1523855789');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn, count) <b>values</b>('The Lost World', 3, '1945644621', 3);</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('A Tale of Two Cities', 4, '0486406510');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn, count) <b>values</b>('Dracula', 5, '0486454016', 4);</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('The Adventures of Tom Sawyer', 6, '1976319161');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('The Prince and the Pauper', 6, '0199539278');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('Adventures of Huckleberry Finn', 6, '0486280615');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Books(title, authorid, isbn) <b>values</b>('The Strange Case of Dr. Jekyll and Mr. Hyde', 7, '0199536228');</code></td></tr></tbody></table>
        <h2>Members table</h2>
        <p>We have two tables left to create, a table for our library members which we will call <code>Members</code> and the <code>Checkedout</code> table which will contain the records of borrowed books. In our <code>Members</code> table we do not split up the member names into surname and given names.</p>
        <table class="tbl">
            <thead>
                <tr>
                    <th>Members</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>id (integer)</td>
                </tr>
                <tr>
                    <td>name (text)</td>
                </tr>
            </tbody>
        </table>
        <p>In a real library membership records include either a phone number and address or a student ID as distinctive identification of an individual. The exact name of members is not all that important to a library. To keep our example simple we will only include an <code>id</code> and a <code>name</code> column, and have only three members for our library.</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>table</b> Members(</code></td></tr><tr><td><code>id integer <b>primary</b> <b>key</b> <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>name text <b>not</b> <b>null</b></code></td></tr><tr><td><code>);</code></td></tr></tbody></table>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Members <b>values</b>(123, 'John Doe');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Members <b>values</b>(124, 'Jane Wilkinson');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Members <b>values</b>(125, 'James Jones');</code></td></tr></tbody></table>
        <h2>Checkedout table</h2>
        <p>In our library we will restrict members to borrowing only one copy of a book at a time. When a book is checked out there are two data points that uniquely identify the transaction: the book's ISBN and the borrower's membership id.</p>
        <table class="tbl">
            <thead>
                <tr>
                    <th>Checkedout</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>memberid (integer)</td>
                </tr>
                <tr>
                    <td>isbn (text)</td>
                </tr>
                <tr>
                    <td>checkoutdate (text)</td>
                </tr>
            </tbody>
        </table>
        <p>Up until now we have been specifying a single column as a primary key. Ideally we would like to use the combination of ISBN and membership ID as a primary key, and not have to create a separate ID column for the <code>Checkedout</code> table. We can specify a composite primary key in much the same way as we did with the foreign key, by placing the declaration after the list of columns:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>table</b> Checkedout(</code></td></tr><tr><td><code>memberid integer <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>isbn text <b>not</b> <b>null</b>,</code></td></tr><tr><td><code>checkoutdate text <b>not</b> <b>null</b>,</code></td></tr><tr><td><code><b>foreign</b> <b>key</b>(memberid) <b>references</b> Members(id),</code></td></tr><tr><td><code><b>foreign</b> <b>key</b>(isbn) <b>references</b> Books(isbn),</code></td></tr><tr><td><code><b>primary</b> <b>key</b>(memberid, isbn)</code></td></tr><tr><td><code>);</code></td></tr></tbody></table>
        <p>When someone borrows a book we record the person's member ID and the book's ISBN. We also record the date when it was borrowed in the <code>checkoutdate</code> column. If a person borrows more than one book, then there will need to be a record for each book borrowed. Since we will be working with these tables in the following chapters we will need to insert a few records into the <code>Checkedout</code> table:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>insert</b> <b>into</b> Checkedout <b>values</b>(123, '0141439513', '2018-03-21');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Checkedout <b>values</b>(123, '0147515874', '2018-03-19');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Checkedout <b>values</b>(123, '3958700152', '2018-03-01');</code></td></tr><tr><td><code></code></td></tr><tr><td><code><b>insert</b> <b>into</b> Checkedout <b>values</b>(125, '3958700152', '2018-03-05');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Checkedout <b>values</b>(125, '1514698854', '2018-03-05');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Checkedout <b>values</b>(125, '1976319161', '2018-03-18');</code></td></tr><tr><td><code><b>insert</b> <b>into</b> Checkedout <b>values</b>(125, '0199539278', '2018-03-18');</code></td></tr></tbody></table>
        <p>So far we have discussed creating tables and indexes. There are only two types of operations left, altering the table definition and constraints after creation, and deleting tables and indexes. We will not be discussing table operations in this chapter for two reasons: Databases implement altering tables slightly differently and SQLite does not support all operations anyway. In addition, databasesâ table specifications are not meant to be changed willy-nilly. (That being said, the 'Table operations' chapter discusses the available statements.) Proper design and planning should eliminate any need to change the structure after creation. The following database design principles should be followed:</p>
        <ul>
            <li>Information should be divided into tables to reduce duplicate / redundant data.</li>
            <li>Each field in the table should only have one value, never a list of values.</li>
            <li>Each field should depend directly on the primary key, rather than indirectly through some other field.</li>
            <li>Every non-key column should be independent of any other non-key column in a table.</li>
        </ul>
        <p>Reexamine the tables that we created with these principles in mind.</p>
        <h3>Data types</h3>
        <p>Notice how in our <code>Checkedout</code> table we used <code>text</code> as the data type for the checkout date. This is because SQLite does not have an explicit date data type. Other databases do. There is little consistency between the data types of various databases. To make matters worse, the data types may be defined differently, despite having the same name. For example, <code>string</code> (which means text) can be stored as a <code>char(size)</code>, <code>varchar(size)</code>, <code>text</code> or <code>nchar(size)</code> depending on which database you are using. Numbers can be stored as <code>bit</code>, <code>int</code>, <code>bigint</code>, <code>float</code>, <code>real</code> etc. depending on the database. Microsoft SQL Server offers 12 different data types for storing strings, 11 data types for storing numbers, and 7 data types for storing dates and times. MySQL offers 14 different data types for strings, 15 for numbers and 5 for dates and times. There is no way around it, the documentation of a database has to be read to make sure you are using the correct data types. When you are dealing with large volumes of data, the size of text fields and numbers matters both in terms of storage and performance. For our purposes it does not. SQLite is used in this book not just because you can experiment with it on your own computer easily, but also because it offers simplicity in terms of data types. </p>
    </section>

    <!-- 3. Querying tables  -->
    <section>
        <h1>3. Querying tables</h1>
        <p>While a spreadsheet is a collection of cells / fields, a database should be thought of as columns of data. When querying a database the first thing the database needs to know is which columns you are interested in and in which tables. Since databases operate in terms of columns the query results will be columns of data. The database can filter the results so that only the records we are interested in are returned, but all query statements start with a list of columns to fetch. Most books and tutorials start with searching for a specific set of records in a table, and then try to tack on querying multiple tables. That is not "thinking in terms of SQL." As we saw in the previous chapter a fundamental design principle of relational databases is that information is divided into tables to reduce duplicate / redundant data. Hence, querying a database almost always involves data from multiple connected tables. We will filter / search for a specific set of records in the following chapters, but in this chapter we are going to concentrate on how to connect / join tables when querying a database.</p>
        <p>All query operations are done with the <code><b>select</b></code> statement. A <code><b>select</b></code> statement can be quite complex with clauses for filtering, sorting and grouping data, but before that can happen we need to specify which columns to retrieve and from which tables. In the previous chapter we saw how to retrieve all data from a table with the following statement:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> * <b>from</b> Authors;</code></td></tr></tbody></table>
        <p>The asterisk is used to signify that we want all columns from the <code>Authors</code> table. Every <code><b>select</b></code> statement starts with the <code><b>select</b></code> keyword, a comma separated list of columns followed by the <code><b>from</b></code> keyword and the table name. Suppose we are interested in the names of authors in our table, but not the IDs. We can retrieve the list using:</p>
        <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> givennames, surname <b>from</b> Authors;</code></td></tr></tbody></table>
        <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Jane|Austen</td></tr><tr><td>Lewis|Caroll</td></tr><tr><td>Arthur Conan|Doyle</td></tr><tr><td>Charles|Dickens</td></tr><tr><td>Bram|Stoker</td></tr><tr><td>Mark|Twain</td></tr><tr><td>Robert Louis|Stevenson</td></tr></tbody></table>
        <p>The retrieved data columns will be in the order listed in our <code><b>select</b></code> statement. If we want <code>surname</code> to appear first, then we would write:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> surname, givennames <b>from</b> Authors;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Austen|Jane</td></tr><tr><td>Caroll|Lewis</td></tr><tr><td>Doyle|Arthur Conan</td></tr><tr><td>Dickens|Charles</td></tr><tr><td>Stoker|Bram</td></tr><tr><td>Twain|Mark</td></tr><tr><td>Stevenson|Robert Louis</td></tr></tbody></table>
            <p>To list all book ISBNs that are currently checked out, we would write:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> isbn <b>from</b> Checkedout;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>0141439513</td></tr><tr><td>0147515874</td></tr><tr><td>3958700152</td></tr><tr><td>0199539278</td></tr><tr><td>1514698854</td></tr><tr><td>1976319161</td></tr><tr><td>3958700152</td></tr></tbody></table>
            <p>As you can see ISBN 3958700152 appears twice, since two copies were borrowed. To get a list without duplicates, we can use the <code><b>distinct</b></code> keyword after the <code><b>select</b></code> keyword:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> <b>distinct</b> isbn <b>from</b> Checkedout;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>0141439513</td></tr><tr><td>0147515874</td></tr><tr><td>3958700152</td></tr><tr><td>0199539278</td></tr><tr><td>1514698854</td></tr><tr><td>1976319161</td></tr></tbody></table>
            <p>However, the <code><b>distinct</b></code> keyword has a drawback. It is applied to the combination of all columns listed in the <code><b>select</b></code> statement, and cannot be applied to only a subset of columns. If we were to list all <code>isbn</code> numbers along with the borrower's <code>memberid</code>, then the combination of the two columns would need to be distinct.</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> <b>distinct</b> memberid, isbn <b>from</b> Checkedout;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|0141439513</td></tr><tr><td>123|0147515874</td></tr><tr><td>123|3958700152</td></tr><tr><td>125|0199539278</td></tr><tr><td>125|1514698854</td></tr><tr><td>125|1976319161</td></tr><tr><td>125|3958700152</td></tr></tbody></table>
            <p>As you can see ISBN 3958700152 appears twice again.</p>
            <h2>Combining / joining tables</h2>
            <p>Our <code>Checkedout</code> table records ISBN and the membership ID for each book borrowed. If we want the borrower's name instead of the ID, then we need to combine the <code>Checkedout</code> table with the <code>Members</code> table. It would be reasonable to assume that listing both tables in the <code><b>from</b></code> clause would yield the desired results. After all, the <code>memberid</code> column in the <code>Checkedout</code> table references the <code>id</code> column in the <code>Members</code> table. This should work:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> isbn, name <b>from</b> Checkedout, Members;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>0141439513|John Doe</td></tr><tr><td>0147515874|John Doe</td></tr><tr><td>3958700152|John Doe</td></tr><tr><td>0199539278|John Doe</td></tr><tr><td>1514698854|John Doe</td></tr><tr><td>1976319161|John Doe</td></tr><tr><td>3958700152|John Doe</td></tr><tr><td>0141439513|Jane Wilkinson</td></tr><tr><td>0147515874|Jane Wilkinson</td></tr><tr><td>3958700152|Jane Wilkinson</td></tr><tr><td>0199539278|Jane Wilkinson</td></tr><tr><td>1514698854|Jane Wilkinson</td></tr><tr><td>1976319161|Jane Wilkinson</td></tr><tr><td>3958700152|Jane Wilkinson</td></tr><tr><td>0141439513|James Jones</td></tr><tr><td>0147515874|James Jones</td></tr><tr><td>3958700152|James Jones</td></tr><tr><td>0199539278|James Jones</td></tr><tr><td>1514698854|James Jones</td></tr><tr><td>1976319161|James Jones</td></tr><tr><td>3958700152|James Jones</td></tr></tbody></table>
            <p>As you can see the database matched up every record in <code>Checkedout</code> with every record in <code>Members</code>, regardless of whether or not the member ID matched. This is referred to as a <i>cross join</i>, and is not what we want most of the time. You could filter the results afterwards to only include the rows for which the IDs match, but that is inefficient and unnecessary. Consider the hypothetical bank example in chapter 1. If you wanted to generate a monthly statement of transactions for an account by filtering a cross join, then the database would need to create a temporary table consisting of 10 million accounts by 50 million transactions per day by 30 days of data, and filter all of that to find the records of a single account.</p>
            <p>For the database to match up records we need to explicitly join the two tables based on a join criterion. There are two types of joins: <i>inner joins</i> and <i>outer joins</i>. Inner joins only return records for which there was a successful match, while outer joins return all records from one table and match up the records from the other table where applicable.</p>
            <p>Let's combine the <code>Checkedout</code> table with the <code>Members</code> table to get the borrower's name instead of the ID using an <code><b>inner</b> <b>join</b></code>. The match criterion is specified after the <code><b>on</b></code> keyword:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> isbn, name <b>from</b> Checkedout <b>inner</b> <b>join</b> Members <b>on</b> memberid=id; </code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>0141439513|John Doe</td></tr><tr><td>0147515874|John Doe</td></tr><tr><td>3958700152|John Doe</td></tr><tr><td>0199539278|James Jones</td></tr><tr><td>1514698854|James Jones</td></tr><tr><td>1976319161|James Jones</td></tr><tr><td>3958700152|James Jones</td></tr></tbody></table>
            <p>You can have multiple joins, one after another. The database will create the first join, then use the results in the next join. For example, if we wanted to retrieve the book titles instead of the ISBNs, then we could use the following two inner joins:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> name, title <b>from</b> Checkedout <b>inner</b> <b>join</b> Members <b>on</b> memberid=id <b>inner</b> <b>join</b> Books <b>on</b> Books.isbn=Checkedout.isbn;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>John Doe|Pride and Prejudice</td></tr><tr><td>John Doe|Alice's Adventures in Wonderland</td></tr><tr><td>John Doe|The Adventures of Sherlock Holmes</td></tr><tr><td>James Jones|The Prince and the Pauper</td></tr><tr><td>James Jones|A Study in Scarlet</td></tr><tr><td>James Jones|The Adventures of Tom Sawyer</td></tr><tr><td>James Jones|The Adventures of Sherlock Holmes</td></tr></tbody></table>
            <p>Notice how we had to specify the table name for the <code>isbn</code> columns in the second inner join: <code>Books.isbn=Checkedout.isbn</code><br>Since the <code>isbn</code> column name is used in both tables the database has no way of determining which columns we are referring to without the fully qualified name.</p>
            <p>In the above example the database returned a list of all members that had entries in the <code>Checkedout</code> table. However, if we want to list all members even if they have no checked out books, then we need to use an outer join. An outer join can be specified with the keywords <code><b>left</b> <b>outer</b> <b>join</b></code>, <code><b>right</b> <b>outer</b> <b>join</b></code> or <code><b>full</b> <b>outer</b> <b>join</b></code>.</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> name, isbn <b>from</b> Members <b>left</b> <b>outer</b> <b>join</b> Checkedout <b>on</b> memberid=id;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>John Doe|0141439513</td></tr><tr><td>John Doe|0147515874</td></tr><tr><td>John Doe|3958700152</td></tr><tr><td>Jane Wilkinson|</td></tr><tr><td>James Jones|0199539278</td></tr><tr><td>James Jones|1514698854</td></tr><tr><td>James Jones|1976319161</td></tr><tr><td>James Jones|3958700152</td></tr></tbody></table>
            <p>We have all members listed and the ISBN of the books that they borrowed. For Jane Wilkinson the ISBN is <code><b>null</b></code>, that is to say the absence of a value. Now we can match up the book titles to the ISBNs:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> name, title <b>from</b> Members <b>left</b> <b>outer</b> <b>join</b> Checkedout <b>on</b> memberid=id <b>inner</b> <b>join</b> Books <b>on</b> Books.isbn=Checkedout.isbn; </code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>John Doe|Pride and Prejudice</td></tr><tr><td>John Doe|Alice's Adventures in Wonderland</td></tr><tr><td>John Doe|The Adventures of Sherlock Holmes</td></tr><tr><td>James Jones|The Prince and the Pauper</td></tr><tr><td>James Jones|A Study in Scarlet</td></tr><tr><td>James Jones|The Adventures of Tom Sawyer</td></tr><tr><td>James Jones|The Adventures of Sherlock Holmes</td></tr></tbody></table>
            <p>Notice how this time around the entry for Jane Wilkinson is missing. The database will create the first join then use the results in the next join. Since the second join is an <code><b>inner</b> <b>join</b></code> and there is no matching ISBN in the <code>Books</code> table, the entry was left out. We need to use <code><b>left</b> <b>outer</b> <b>join</b></code> for both joins to get the desired results:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> name, title <b>from</b> Members <b>left</b> <b>outer</b> <b>join</b> Checkedout <b>on</b> memberid=id <b>left</b> <b>outer</b> <b>join</b> Books <b>on</b> Books.isbn=Checkedout.isbn;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>John Doe|Pride and Prejudice</td></tr><tr><td>John Doe|Alice's Adventures in Wonderland</td></tr><tr><td>John Doe|The Adventures of Sherlock Holmes</td></tr><tr><td>Jane Wilkinson|</td></tr><tr><td>James Jones|The Prince and the Pauper</td></tr><tr><td>James Jones|A Study in Scarlet</td></tr><tr><td>James Jones|The Adventures of Tom Sawyer</td></tr><tr><td>James Jones|The Adventures of Sherlock Holmes</td></tr></tbody></table>
            <p>Above we specified that all rows from the left hand side table need to be included using <code><b>left</b> <b>outer</b> <b>join</b></code>. To have all rows from the right hand side table included instead of the left hand side, you would use the <code><b>right</b> <b>outer</b> <b>join</b></code> keywords. A <code><b>right</b> <b>outer</b> <b>join</b></code> is the equivalent of switching up the tables in the <code><b>left</b> <b>outer</b> <b>join</b></code> statement. SQL also has <code><b>full</b> <b>outer</b> <b>join</b></code>, which returns all rows from both tables in the join, matching up the rows where applicable. When there is no matching row, <code><b>null</b></code> is included in the columns as in the case of the Jane Wilkinson entry above. SQLite does not support either <code><b>right</b> <b>outer</b> <b>join</b></code> or <code><b>full</b> <b>outer</b> <b>join</b></code>, hence a working example is not provided here. </p>
            <p>Every join includes a comparison criterion after the <code><b>on</b></code> keyword. So far we have only used equality, but other comparison operators (&lt;, &gt;, &lt;=, &gt;=, !=) work as well. We only used one criterion, since we only needed one. However, you can include more than one using the <code><b>and</b></code> and <code><b>or</b></code> operators, or negate a condition using the <code><b>not</b></code> operator. For example, to list all borrowed books for members whose ID is greater than 123:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> name, isbn <b>from</b> Members <b>inner</b> <b>join</b> Checkedout </code></td></tr><tr><td><code><b>on</b> memberid=id <b>and</b> id&gt;123;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>James Jones|0199539278</td></tr><tr><td>James Jones|1514698854</td></tr><tr><td>James Jones|1976319161</td></tr><tr><td>James Jones|3958700152</td></tr></tbody></table>
            <p>One more example using the <code><b>not</b></code> operator:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> name, isbn <b>from</b> Members <b>inner</b> <b>join</b> Checkedout </code></td></tr><tr><td><code><b>on</b> memberid=id <b>and</b> <b>not</b> id&gt;123;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>John Doe|0141439513</td></tr><tr><td>John Doe|0147515874</td></tr><tr><td>John Doe|3958700152</td></tr></tbody></table>
            <p>However, at this point we are filtering data. Filtering should be done using the <code><b>where</b></code> clause of the <code><b>select</b></code> statement instead, discussed in the next chapter.</p>
    </section>

        <!-- 4. Filtering and sorting results -->
        <section>
            <h1>4. Filtering and sorting results</h1>
            <p>As we saw in the previous chapter the <code><b>select</b></code> statement can be used to combine tables and produce reports of the data, including / excluding columns as desired. The <code><b>select</b></code> statement is used for all querying operations. Once we have the columns that we need from the appropriate tables, the <code><b>where</b></code> clause can be used to filter the results of the <code><b>select</b></code> statement. When joining tables we used comparison criteria to specify how the database should match up records. The <code><b>where</b></code> clause uses the same type of comparisons, and comes after the <code><b>from</b></code> clause, including joins. Let's list all books in the library with more than one copy, along with the author names. First, we need to specify the columns that we want returned and join the appropriate tables:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title, surname, givennames, count <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> authorid=id;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Pride and Prejudice|Austen|Jane|2</td></tr><tr><td>Alice's Adventures in Wonderland|Caroll|Lewis|1</td></tr><tr><td>The Adventures of Sherlock Holmes|Doyle|Arthur Conan|3</td></tr><tr><td>A Study in Scarlet|Doyle|Arthur Conan|1</td></tr><tr><td>The Sign of the Four|Doyle|Arthur Conan|1</td></tr><tr><td>The Lost World|Doyle|Arthur Conan|3</td></tr><tr><td>A Tale of Two Cities|Dickens|Charles|1</td></tr><tr><td>Dracula|Stoker|Bram|4</td></tr><tr><td>The Adventures of Tom Sawyer|Twain|Mark|1</td></tr><tr><td>The Prince and the Pauper|Twain|Mark|1</td></tr><tr><td>Adventures of Huckleberry Finn|Twain|Mark|1</td></tr><tr><td>The Strange Case of Dr. Jekyll and Mr. Hyde|Stevenson|Robert Louis|1</td></tr></tbody></table>
            <p>Next, we can filter for the records that have more than one copy:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title, surname, givennames, count <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> authorid=id <b>where</b> count&gt;1;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Pride and Prejudice|Austen|Jane|2</td></tr><tr><td>The Adventures of Sherlock Holmes|Doyle|Arthur Conan|3</td></tr><tr><td>The Lost World|Doyle|Arthur Conan|3</td></tr><tr><td>Dracula|Stoker|Bram|4</td></tr></tbody></table>
            <p>Suppose we wanted to know which members have borrowed "The Adventures of Sherlock Holmes" book. We can use the <code><b>where</b></code> clause to filter by ISBN, which is 3958700152:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid <b>from</b> Checkedout <b>where</b> isbn='3958700152';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123</td></tr><tr><td>125</td></tr></tbody></table>
            <p>Note that the <code>isbn</code> column in the <code>Checkedout</code> table is defined as text. Hence, the number was specified in quotes for the comparison. If we need the member names in addition to their <code>id</code>, then we need to join tables before filtering for the ISBN:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, name <b>from</b> Checkedout <b>inner</b> <b>join</b> Members <b>on</b> memberid=id <b>where</b> isbn='3958700152';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|John Doe</td></tr><tr><td>125|James Jones</td></tr></tbody></table>
            <p>If we would like to find all books by Mark Twain, then we need to join the <code>Books</code> and <code>Authors</code> tables first, and then filter for the author's name:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> authorid=id <b>where</b> surname='Twain';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>The Adventures of Tom Sawyer</td></tr><tr><td>The Prince and the Pauper</td></tr><tr><td>Adventures of Huckleberry Finn</td></tr></tbody></table>
            <p>Note that when we created the <code>Books</code> table we set the collation of the <code>title</code> column to <code><b>collate</b> nocase</code>. However, when creating the <code>Authors</code> table the collation of the authors' <code>surname</code> and <code>givennames</code> was not changed. Since the default collation is case sensitive, trying to filter the results using <code>surname='twain'</code> would not have worked. The statement completes without errors, but returns no results. The collation can be changed in the <code><b>where</b></code> clause itself, if needed:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> authorid=id <b>where</b> surname='twain' <b>collate</b> nocase;</code></td></tr></tbody></table>
            <p>Be aware that when collation is used as part of a <code><b>where</b></code> clause it always causes the database to scan every field in the column, ignoring any index. This will be inefficient. The collation of columns should be set appropriately at table creation. (Databases support a variety of collation options based on language and locale, often with different names. The <code>nocase</code> collation name is specific to SQLite.)</p>
            <p>Suppose we would like to find all books by Mark Twain that have been borrowed, we would use the following:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> authorid=id <b>inner</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn <b>where</b> surname='Twain';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>The Prince and the Pauper</td></tr><tr><td>The Adventures of Tom Sawyer</td></tr></tbody></table>
            <p>Above we first joined the <code>Authors</code> table with the <code>Books</code> table to associate the books with authors. The resulting dataset was then joined with the <code>Checkedout</code> table to get all the books that were checked out with the book titles and authors. Thereafter we could filter the data based on the author's <code>surname</code>. The <code><b>where</b></code> clause always comes after the <code><b>from</b></code> clause, including joins. Logical operators <code><b>and</b></code>, <code><b>or</b></code> and <code><b>not</b></code> can be used in the <code><b>where</b></code> clause. Both member ID 123 and 125 borrowed books written by Arthur Conan Doyle. To find which books were borrowed by member ID 125 that were written by Arthur Conan Doyle, we would use the <code><b>and</b></code> operator as follows:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title, surname, memberid <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> authorid=id <b>inner</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn <b>where</b> surname='Doyle' <b>and</b> memberid=125;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>A Study in Scarlet|Doyle|125</td></tr><tr><td>The Adventures of Sherlock Holmes|Doyle|125</td></tr></tbody></table>
            <h2>Comparison operators</h2>
            <h3><code><b>in</b></code> operator</h3>
            <p>The <code><b>in</b></code> operator determines whether a column value matches any value in a list.
                The comma separated list of values to match against can be specified between parentheses after the <code><b>in</b></code> operator. For example, to list a specific set of authors from the <code>Authors</code> table we can use the <code><b>in</b></code> operator as follows:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> id, givennames, surname <b>from</b> Authors <b>where</b> surname <b>in</b> ('Twain', 'Doyle', 'Dickens');</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>4|Charles|Dickens</td></tr><tr><td>3|Arthur Conan|Doyle</td></tr><tr><td>6|Mark|Twain</td></tr></tbody></table>
            <p>The <code><b>in</b></code> expression is equivalent to a series of equality comparisons combined with the <code><b>or</b></code> operator:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> id, givennames, surname <b>from</b> Authors <b>where</b> </code></td></tr><tr><td><code>(surname='Twain'</code></td></tr><tr><td><code><b>or</b> surname='Doyle'</code></td></tr><tr><td><code><b>or</b> surname='Dickens');</code></td></tr><tr><td><code></code></td></tr></tbody></table>
            <p>Note that the expanded equivalent is within parentheses, thus ensuring that all the <code><b>or</b></code> conditions are evaluated as a single unit. This is important because the <code><b>or</b></code> operator has the lowest precedence of all operators. The <code><b>in</b></code> operator can be combined with <code><b>not</b></code> to list all authors except the ones in our list:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> id, givennames, surname <b>from</b> Authors <b>where</b> surname <b>not</b> <b>in</b> ('Twain', 'Doyle', 'Dickens');</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>1|Jane|Austen</td></tr><tr><td>2|Lewis|Caroll</td></tr><tr><td>5|Bram|Stoker</td></tr><tr><td>7|Robert Louis|Stevenson</td></tr></tbody></table>
            <p>Similarly, <code><b>not</b> <b>in</b></code> is equivalent to a series of inequality comparisons combined with the <code><b>and</b></code> operator:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> id, givennames, surname <b>from</b> Authors <b>where</b> </code></td></tr><tr><td><code>(surname!='Twain'</code></td></tr><tr><td><code><b>and</b> surname!='Doyle'</code></td></tr><tr><td><code><b>and</b> surname!='Dickens');</code></td></tr><tr><td><code></code></td></tr></tbody></table>
            <p>This can result in unexpected results if a column contains <code><b>null</b></code> values, since <code><b>null</b> <b>and</b> true</code> evaluates to <code><b>null</b></code>, while <code><b>null</b> <b>or</b> true</code> evaluates to <code>true</code>. The following table shows the results of applying an <code><b>and</b></code> operator to two boolean expressions where one expression returns <code><b>null</b></code>.
            </p>
            <table class="tbl">
                <thead>
                    <tr>
                        <th>Expression 1</th>
                        <th>Expression 2</th>
                        <th>Result of AND</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>true</td>
                        <td>null</td>
                        <td>null</td>
                    </tr>
                    <tr>
                        <td>null</td>
                        <td>null</td>
                        <td>null</td>
                    </tr>
                    <tr>
                        <td>false</td>
                        <td>null</td>
                        <td>false</td>
                    </tr>
                </tbody>

            </table>
            <p>The following table shows the results of applying an <code><b>or</b></code> operator to two boolean expressions where one expression returns <code><b>null</b></code>.</p>
            <table class="tbl">
                <thead>
                    <tr>
                        <th>Expression 1</th>
                        <th>Expression 2</th>
                        <th>Result of OR</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>true</td>
                        <td>null</td>
                        <td>true</td>
                    </tr>
                    <tr>
                        <td>null</td>
                        <td>null</td>
                        <td>null</td>
                    </tr>
                    <tr>
                        <td>false</td>
                        <td>null</td>
                        <td>null</td>
                    </tr>
                </tbody>

            </table>
            <p>The <code><b>in</b></code> operator is useful not just for readability reasons, but also because it can contain a subquery instead of a list. The subquery must have a result set of one column. This column must have the same data type as the column we are matching against. Previously we used the following to find all books by Mark Twain that have been borrowed:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> authorid=id <b>inner</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn <b>where</b> surname='Twain';</code></td></tr></tbody></table>
            <p>This can be rewritten using a nested <code><b>select</b></code>:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>inner</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn <b>where</b> authorid <b>in</b> (</code></td></tr><tr><td><code><b>select</b> id <b>from</b> Authors <b>where</b> surname='Twain'</code></td></tr><tr><td><code>);</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>The Prince and the Pauper</td></tr><tr><td>The Adventures of Tom Sawyer</td></tr></tbody></table>
            <p>Databases are usually used in applications where speed and efficiency matters. A common question would be, which query is faster or better, the nested <code><b>select</b></code> or the join? The answer is, it depends. Modern databases (read all enterprise databases) analyze your query and will change it to optimize for performance. Depending on how your tables are organized and what indexes are set up the database may change your nested <code><b>select</b></code> statement to a join behind the scenes, or vice versa. Performance has to be measured to determine which query produces faster results for a specific combination of tables / data / database. In our example there is an index for author names, specifically <code>Authorname <b>on</b> Authors(surname, givennames)</code>. Thus, both types of queries will be fast.
            </p>
            <h3><code><b>exists</b></code> operator</h3>
            <p>The <code><b>exists</b></code> operator test for the existence of rows in the result of a subquery. The subquery needs to be within parentheses after the <code><b>exists</b></code> keyword. The test is successful (returns <code>true</code>), if the subquery returns at least one row. The <code><b>exists</b></code> operator is similar in function to the <code><b>in</b></code> operator. We can rewrite the previous query to find all books by Mark Twain that have been borrowed using <code><b>exists</b></code> as follows:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>inner</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn <b>where</b> <b>exists</b> (</code></td></tr><tr><td><code><b>select</b> <b>null</b> <b>from</b> Authors <b>where</b> Authors.surname='Twain' <b>and</b> Authors.id=Books.authorid</code></td></tr><tr><td><code>);</code></td></tr><tr><td><code></code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>The Prince and the Pauper</td></tr><tr><td>The Adventures of Tom Sawyer</td></tr></tbody></table>
            <p>While most <code><b>in</b></code> conditions can be written as <code><b>exists</b></code> conditions, and vice versa, there are key differences between the <code><b>in</b></code> and <code><b>exists</b></code> operators. The database compares all values in the <code><b>in</b></code> operator, but will stop the process as soon as it finds a single result in for the <code><b>exists</b></code> operator. The result of <code><b>exists</b></code> can be either <code>true</code> or <code>false</code>, while the result of <code><b>in</b></code> can be <code>true</code> or <code>false</code> or <code><b>null</b></code>. The <code><b>in</b></code> operator can have multiple direct values instead of a subquery, but <code><b>null</b></code> cannot be compared using the <code><b>in</b></code> operator. Conversely, <code><b>null</b></code> can be compared using the <code><b>exists</b></code> operator, but the condition in parentheses cannot be specified directly, it must always be a subquery. There are four more operators that can be used in comparison conditions: <code><b>between</b></code>, <code><b>all</b></code>, <code><b>any</b></code> and <code><b>some</b></code>.</p>
            <h3><code><b>between</b></code> operator</h3>
            <p>When working with ranges of values instead of lists, the <code><b>between</b></code> operator is handy from a readability and code clarity perspective. The <code><b>between</b></code> operator is inclusive of the beginning and end value of the range and works with numbers as well as text. (For databases that have explicit date / time data types it works on those types as well.) When working with text the collation of the column will effect the results. Example of the between operator:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> id, surname <b>from</b> Authors <b>where</b> surname <b>between</b> 'Doyle' <b>and</b> 'Twain';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>3|Doyle</td></tr><tr><td>7|Stevenson</td></tr><tr><td>5|Stoker</td></tr><tr><td>6|Twain</td></tr></tbody></table>
            <h3><code><b>all</b></code>, <code><b>some</b></code>, <code><b>any</b></code> operator</h3>
            <p>The <code><b>all</b></code>, <code><b>any</b></code> and <code><b>some</b></code> comparison conditions are used to compare a value to a list or subquery. They must be preceded by a comparison operator (=, !=, &lt;, &gt;, &gt;=, &lt;=) and followed by a list or subquery in parentheses. (The <code><b>between</b></code>, <code><b>in</b></code> and <code><b>exists</b></code> operators do not have a comparison operator preceding them.) The <code><b>all</b></code> condition is equivalent a series of comparisons combined with the <code><b>and</b></code> operator. The <code><b>any</b></code> and <code><b>some</b></code> conditions are interchangeable. Both conditions are equivalent a series of comparisons combined with the <code><b>or</b></code> operator.</p>

            <h3><code><b>like</b></code> operator</h3>
            <p>The operators thus far have filtered based on known exact values or ranges. A record matched exactly, or not. With the <code><b>like</b></code> operator we can search for partial values, much like with a search engine. The <code><b>like</b></code> operator matches every field value in a column against a string containing a combination of text and wildcards. There are two commonly supported wildcards: <code>%</code> (percentage) which matches any string of zero or more characters and <code>_</code> (underscore) which matches any single character. For example, let's find all books in the catalog with the word 'adventure' in the title:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>where</b> title <b>like</b> ('%Adventure%');</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Alice's Adventures in Wonderland</td></tr><tr><td>The Adventures of Sherlock Holmes</td></tr><tr><td>The Adventures of Tom Sawyer</td></tr><tr><td>Adventures of Huckleberry Finn</td></tr></tbody></table>
            <p>To find all 'Sherlock Holmes' books that have been borrowed:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title, memberid <b>from</b> Books <b>inner</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn <b>where</b> title <b>like</b> ('%Sherlock Holmes%');</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>The Adventures of Sherlock Holmes|123</td></tr><tr><td>The Adventures of Sherlock Holmes|125</td></tr><tr><td></td></tr></tbody></table>
            <p>The collation of a column may effect the results. You can change the collation of a column for the query with the <code><b>collate</b></code> keyword and collation name right after the column name, e.g.:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title <b>from</b> Books <b>where</b> title <b>collate</b> nocase <b>like</b> ('%sawyer%');</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>The Adventures of Tom Sawyer</td></tr></tbody></table>
            <p>Collation is quite an involved topic and databases support a variety of collation options based on language and locale, often with different names. The <code>nocase</code> collation name is specific to SQLite. Note that filtering with <code><b>like</b></code> will necessitate that the database look at every value in the column of interest, also called a full table scan. Depending on the size of the data, this can take significantly longer than other query operations.
            </p>
            <h3>Operator precedence</h3>
            <p>Up until now all the examples shown have been evaluated from left to right. However, this is not always the case. Multiple comparisons in the <code><b>where</b></code> clause will not necessarily be evaluated from left to right. For example: <code><i>comparison1</i> <b>or</b> <i>comparison2</i> <b>and</b> <i>comparison3</i></code><br>
                The above is not evaluated from left to right, since <code><b>and</b></code> has higher precedence than <code><b>or</b></code>. Hence, the expression will be evaluated as follows:<code> <i>comparison1</i> <b>or</b> (<i>comparison2</i> <b>and</b> <i>comparison3</i>)</code><br>
                It is best to include parentheses to ensure that the comparisons are evaluated as you intended. Make sure you read the operator evaluation order from the reference manual of the database that you are using, because operator precedence differs between databases. For example, MySQL treats <code><b>between</b></code> as lower precedence than <code><b>like</b></code>, <code><b>in</b></code> or other comparison operators, while Oracle assigns the same precedence level. Microsoft SQL Server assigns the lowest precedence level to <code><b>all</b></code>, <code><b>any</b></code>, <code><b>between</b></code>, <code><b>in</b></code>, <code><b>like</b></code>, <code><b>some</b></code> and <code><b>or</b></code>. Parentheses ensure that your query works as intended regardless of the database that you are using.
            </p>
            <h2>Sorting the results</h2>
            <p>Sorting should always be the last clause of the <code><b>select</b></code> statement. Each clause of the <code><b>select</b></code> statement may change the order of records. We can sort based on either one column or a combination of columns using the <code><b>order</b> <b>by</b></code> keywords. The default sort order is ascending, but this can be changed using the <code><b>desc</b></code> keyword. For example, to sort books in the <code>Books</code> table based on the number of copies, descending:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title, count <b>from</b> Books <b>order</b> <b>by</b> count <b>desc</b>;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Dracula|4</td></tr><tr><td>The Adventures of Sherlock Holmes|3</td></tr><tr><td>The Lost World|3</td></tr><tr><td>Pride and Prejudice|2</td></tr><tr><td>Alice's Adventures in Wonderland|1</td></tr><tr><td>A Study in Scarlet|1</td></tr><tr><td>The Sign of the Four|1</td></tr><tr><td>A Tale of Two Cities|1</td></tr><tr><td>The Adventures of Tom Sawyer|1</td></tr><tr><td>The Prince and the Pauper|1</td></tr><tr><td>Adventures of Huckleberry Finn|1</td></tr><tr><td>The Strange Case of Dr. Jekyll and Mr. Hyde|1</td></tr></tbody></table>
            <p>To sort borrowed books by member ID and then book title we would use the following:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, title <b>from</b> Checkedout <b>inner</b> <b>join</b> Books <b>on</b> Books.isbn=Checkedout.isbn <b>order</b> <b>by</b> memberid, title;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|Alice's Adventures in Wonderland</td></tr><tr><td>123|Pride and Prejudice</td></tr><tr><td>123|The Adventures of Sherlock Holmes</td></tr><tr><td>125|A Study in Scarlet</td></tr><tr><td>125|The Adventures of Sherlock Holmes</td></tr><tr><td>125|The Adventures of Tom Sawyer</td></tr><tr><td>125|The Prince and the Pauper</td></tr></tbody></table>
            <p>The collation of columns will affect the sort order. You can set the collation after the column name of the <code><b>order</b> <b>by</b></code> clause with the <code><b>collate</b></code> keyword followed by the collation name.</p>
        </section>

        <!-- 5. Grouping, aggregating and analytics -->
        <section>
            <h1>5. Grouping, aggregating and analytics</h1>
            <p>End users do not usually access databases directly. Instead they use frontend applications which interact with a backend database. Frontend applications often have to process the raw data returned from the database to create aggregates and summaries. In addition, text processing may have to be done to display the data in a user friendly manner. When dealing with large amounts of data it is much faster to do some of the processing on the database end. There are five functions that are supported by every database within the select statement: <code>count()</code>, <code>sum()</code>, <code>avg()</code>, <code>min()</code> and <code>max()</code>. These functions can be used in both the column names after the <code><b>select</b></code> keyword as well as within clauses.</p>
            <h3>Count() function</h3>
            <p>The <code>count()</code> function counts the number of rows. <code>Count(*)</code> returns the total number of rows including ones with <code><b>null</b></code> fields. When used with a column name instead of <code>*</code>, it returns the total number of rows excluding the ones with <code><b>null</b></code>. (Our example tables do not have <code><b>null</b></code> entries. As such, there is no difference in using either form.) For example, to count the number of book titles in our library we could query the database as follows:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> count(title) <b>from</b> Books;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>12</td></tr></tbody></table>
            <p>To get the number of titles from Mark Twain, we need to filter the results with the <code><b>where</b></code> clause:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> count(title) <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> Books.authorid=Authors.id <b>where</b> surname='Twain';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>3</td></tr></tbody></table>
            <p>In addition to functions we can also use mathematical operators as well as text manipulation on column names. Text concatenation is done using <code>||</code> in most databases, except Microsoft SQL server which uses the <code>+</code> sign. MySQL and MariaDB support neither, you have to use their <code>concat()</code> function. For example:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> 'Catalog contains ' || count(title) || ' books from the author ' || Authors.givennames || ' ' || Authors.surname <b>from</b> Books <b>inner</b> <b>join</b> Authors <b>on</b> Books.authorid=Authors.id <b>where</b> surname='Twain';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Catalog contains 3 books from the author Mark Twain</td></tr></tbody></table>
            <p>Now, letâs find the number of borrowed books written by Mark Twain. As before, we will need to join the <code>Checkedout</code> table with the <code>Books</code> table to get the ISBN of the borrowed books matched up with the author IDs. To filter based on author name, we will need to join the results with the <code>Authors</code> table:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> count(*) <b>from</b> Checkedout <b>inner</b> <b>join</b> Books <b>on</b> Checkedout.isbn=Books.isbn <b>inner</b> <b>join</b> Authors <b>on</b> authorid=Authors.id <b>where</b> surname='Twain';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>2</td></tr></tbody></table>
            <p>Let's print all the books that have been borrowed, and retrieve the authors' last name as well:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title, surname <b>from</b> Checkedout <b>inner</b> <b>join</b> Books <b>on</b> Checkedout.isbn=Books.isbn <b>inner</b> <b>join</b> Authors <b>on</b> authorid=Authors.id;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>Pride and Prejudice|Austen</td></tr><tr><td>Alice's Adventures in Wonderland|Caroll</td></tr><tr><td>The Adventures of Sherlock Holmes|Doyle</td></tr><tr><td>The Prince and the Pauper|Twain</td></tr><tr><td>A Study in Scarlet|Doyle</td></tr><tr><td>The Adventures of Tom Sawyer|Twain</td></tr><tr><td>The Adventures of Sherlock Holmes|Doyle</td></tr></tbody></table>
            <p>As you can see two copies of the book "The Adventures of Sherlock Holmes" have been borrowed. If we wanted to know how many books by Arthur Conan Doyle have been borrowed, then we could modify the previous query as follows:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> count(*) <b>from</b> Checkedout <b>inner</b> <b>join</b> Books <b>on</b> Checkedout.isbn=Books.isbn <b>inner</b> <b>join</b> Authors <b>on</b> authorid=Authors.id <b>where</b> surname='Doyle';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>3</td></tr></tbody></table>
            <p>However, the above query returns the number of copies, not the number of distinct titles. The <code><b>distinct</b></code> keyword can be used not just after the <code><b>select</b></code> statement, but also within functions:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> count(<b>distinct</b> Checkedout.isbn) <b>from</b> Checkedout <b>inner</b> <b>join</b> Books <b>on</b> Checkedout.isbn=Books.isbn <b>inner</b> <b>join</b> Authors <b>on</b> authorid=Authors.id <b>where</b> surname='Doyle';</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>2</td></tr></tbody></table>
            <p>Some of the titles in our <code>Books</code> table have multiple copies. If we would like to know the total number of books, as opposed to titles, we would need to use the <code>sum()</code> function. The <code>count()</code> functions counts the number of rows, it does not take into account the field values.</p>
            <h3>Sum() function</h3>
            <p>The <code>sum()</code> function returns the sum of values in a column, excluding <code><b>null</b></code> values. (Anything plus <code><b>null</b></code> would be a <code><b>null</b></code>, e.g. <code>2 + <b>null</b>=<b>null</b></code>.) For example, to find the total number of books in the library, not just the total number of titles, we can sum the <code>count</code> column of the <code>Books</code> table:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> count(title), sum(count) <b>from</b> Books;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>12|20</td></tr></tbody></table>
            <p>The <code>Books</code> table contains 12 titles, 20 books in total. When we created the <code>Books</code> table we deliberately did not include a column for the number of copies that are available to be borrowed. If we had such a column, then we would need to make sure that the <code>Books</code> table is updated every time the <code>Checkedout</code> table is updated. This would have introduced the possibility of errors and inconsistencies between tables. Moreover, we would have been duplicating data, since the value can be derived readily from the existing tables. For example, to get the number of available books for ISBN 3958700152 ("The Adventures of Sherlock Holmes"):</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> title, 'Total: ' || Books.count, 'Borrowed: ' || count(Checkedout.isbn), 'Available: ' || (Books.count - count(Checkedout.isbn)) <b>from</b> Books <b>inner</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn</code></td></tr><tr><td><code><b>where</b> Checkedout.isbn=3958700152;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>The Adventures of Sherlock Holmes|Total: 3|Borrowed: 2|Available: 1</td></tr></tbody></table>
            <p>To get a full list of all books, not just a single ISBN, we need to group the books in the <code>Checkedout</code> table using the <code><b>group</b> <b>by</b></code> statement and count the number of rows per group. This will be done in the next sections.</p>
            <h3>Avg(), min() and max() functions</h3>
			<p>The other three functions can be used in a similar manner. The <code>avg()</code> function returns the average of a column, excluding <code><b>null</b></code> values. It is the equivalent of <code>sum()/count()</code> for the column, which both exclude <code><b>null</b></code> values. The <code>min()</code> and <code>max()</code> functions return the minimum and maximum values of a column, respectively. Like the other functions these also eliminate <code><b>null</b></code> values before returning a result.</p>
            <p>Databases support additional text functions, numeric / math functions, date / time functions as well as functions related to database management. However, function names and their exact behavior will differ between databases. You will need to consult the reference manual of the DBMS you are using to get a full list of supported functions.</p>
            <p>While most databases support date and time data types, SQLite does not. As such we set up the checkout date as a text column in the <code>Checkedout</code> table. In order to use the field values as dates we need to use a date functions specific to SQLite. In the following example we use '2018-04-15' as the current date and calculate the number of days since the checkout date of books:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, julianday('2018-04-15') - julianday(checkoutdate) <b>from</b> Checkedout;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|0141439513|25.0</td></tr><tr><td>123|0147515874|27.0</td></tr><tr><td>123|3958700152|45.0</td></tr><tr><td>125|3958700152|41.0</td></tr><tr><td>125|1514698854|41.0</td></tr><tr><td>125|1976319161|28.0</td></tr><tr><td>125|0199539278|28.0</td></tr></tbody></table>
            <p>To query the list for books that were borrowed more than 30 days after '2018-04-15' we need to filter the results with the <code><b>where</b></code> clause as usual:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, julianday('2018-04-15') - julianday(checkoutdate) <b>from</b> Checkedout <b>where</b> julianday('2018-04-15') - julianday(checkoutdate)&gt;30;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|3958700152|45.0</td></tr><tr><td>125|3958700152|41.0</td></tr><tr><td>125|1514698854|41.0</td></tr></tbody></table>
            <h2>Grouping results</h2>
            <p>So far we have used functions on entire columns, or a subset of data that was filtered with the <code><b>where</b></code> clause. We were able to calculate the number of available copies for a single book title, but not all book titles at once. To get a full list of all books we need to group the books in the <code>Checkedout</code> table using the <code><b>group</b> <b>by</b></code> clause and count the number of rows per group. First, let's see how the <code><b>group</b> <b>by</b></code> clause works with a couple of straight forward examples. To count the number of books borrowed by members we need to group the <code>Checkedout</code> table based on the member ID:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, count(isbn) <b>from</b> Checkedout <b>group</b> <b>by</b> memberid;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|3</td></tr><tr><td>125|4</td></tr></tbody></table>
            <p>Member ID 123 borrowed 3 books in total, that is to say there are 3 rows in the <code>Checkededout</code> table for member ID 123. Member ID 125 borrowed 4 books.</p>
            <p>Using the <code><b>group</b> <b>by</b></code> clause we can count the number of borrowed copies for books from the <code>Checkedout</code> table:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> isbn, count(isbn) <b>from</b> Checkedout <b>group</b> <b>by</b> isbn;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>0141439513|1</td></tr><tr><td>0147515874|1</td></tr><tr><td>0199539278|1</td></tr><tr><td>1514698854|1</td></tr><tr><td>1976319161|1</td></tr><tr><td>3958700152|2</td></tr></tbody></table>
            <p>We have 7 records in our <code>Checkedout</code> table, 2 of which are for the same ISBN.
                We can filter the results of the grouping using the <code><b>having</b></code> clause much the same way we filtered results using the <code><b>where</b></code> clause. To list only the books for which more than one copy was borrowed, we would use the following query:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> isbn, count(isbn) <b>from</b> Checkedout <b>group</b> <b>by</b> isbn <b>having</b> count(isbn)&gt;1;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>3958700152|2</td></tr></tbody></table>
            <p><code>Having</code> is the equivalent of the <code><b>where</b></code> clause, but it is specifically for filtering in the <code><b>group</b> <b>by</b></code> clause. The <code><b>where</b></code> clause filters data before it is grouped, while having filters the groupings themselves. The <code><b>having</b></code> clause can only appear after a <code><b>group</b> <b>by</b></code> clause.</p>
            <p>If we want to count and group the books that are more than 30 days overdue (assuming a current date of '2018-04-15'), then we would first need to filter with the <code><b>where</b></code> clause before grouping:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, 'Overdue count: ' || count(isbn) <b>from</b> Checkedout <b>where</b> julianday('2018-04-15') - julianday(checkoutdate)&gt;30 <b>group</b> <b>by</b> memberid;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|Overdue count: 1</td></tr><tr><td>125|Overdue count: 2</td></tr></tbody></table>
            <p>Now let's calculate the number of available copies for every book title in our library. We need to join the <code>Books</code> table with the <code>Checkedout</code> table using a <code><b>left</b> <b>outer</b> <b>join</b></code>. This ensures that all books are listed. Even though we are using the <code>count()</code> function to count the number of rows per ISBN in the <code>Checkedout</code> table, we need to <code><b>group</b> <b>by</b></code> the ISBNs in the <code>Books</code> table. Otherwise the <code><b>group</b> <b>by</b></code> clause would remove the ISBN records that are not present in the <code>Checkedout</code> table.</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> Books.isbn, 'Total: ' || Books.count, 'Available: ' || (Books.count-count(Checkedout.isbn)) <b>from</b> Books <b>left</b> <b>outer</b> <b>join</b> Checkedout <b>on</b> Books.isbn=Checkedout.isbn <b>group</b> <b>by</b> Books.isbn;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>0141439513|Total: 2|Available: 1</td></tr><tr><td>0147515874|Total: 1|Available: 0</td></tr><tr><td>0199536228|Total: 1|Available: 1</td></tr><tr><td>0199539278|Total: 1|Available: 0</td></tr><tr><td>0486280615|Total: 1|Available: 1</td></tr><tr><td>0486406510|Total: 1|Available: 1</td></tr><tr><td>0486454016|Total: 4|Available: 4</td></tr><tr><td>1514698854|Total: 1|Available: 0</td></tr><tr><td>1523855789|Total: 1|Available: 1</td></tr><tr><td>1945644621|Total: 3|Available: 3</td></tr><tr><td>1976319161|Total: 1|Available: 0</td></tr><tr><td>3958700152|Total: 3|Available: 1</td></tr></tbody></table>
            <h2>Analytic functions</h2>
            <p>Often data stored in databases deals with series where data analysis involves using previous values in the series. However, rows in a table have no awareness of other rows. A table consists of independent records, not a series of records. Thus, any data analysis calculations would need to be done prior to the data being inserted into the database. In addition to the data, the tables would need to contain additional columns for the calculated / derived fields. However, two principles of good relational database design dictate that there should be no fields that are derived from or could be derived from other fields:</p>
            <ul>
                <li>Each field should depend directly on the primary key, rather than indirectly through some other field.</li>
                <li>Every non-key column should be independent of any other non-key column in a table.</li>
            </ul>
            <p>SQL window functions overcome the inherent limitation of relational databases and allow for using functions over a range of rows without having to group the rows. Thus, a moving average can be calculated for each row as part of a select statement, without having to calculate it before the record is inserted into the database. A function is turned into a window function when an <code><b>over</b></code> clause is placed after it. Instead of grouping the data, we specify which part of the table the function should be evaluated on. How a table is to be divided up into partitions is specified using an expression in parentheses after the <code><b>over</b></code> keyword. For example, to count the number of books borrowed by members, instead of grouping based on the <code>memberid</code>, we divide up / partition the table based on <code>membereid</code>:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, count(isbn) <b>over</b>(<b>partition</b> <b>by</b> memberid) <b>from</b> Checkedout;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|0141439513|3</td></tr><tr><td>123|0147515874|3</td></tr><tr><td>123|3958700152|3</td></tr><tr><td>125|0199539278|4</td></tr><tr><td>125|1514698854|4</td></tr><tr><td>125|1976319161|4</td></tr><tr><td>125|3958700152|4</td></tr></tbody></table>
            <p>Notice how the count is now included with every row returned by the query. The expression in parentheses after the <code><b>over</b></code> keyword is called the <code><b>partition</b></code> clause of the window definition. It is optional, if the <code><b>partition</b></code> clause is left out then the function is applied to all records, meaning the partition is the entire table:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, count(isbn) <b>over</b>() <b>from</b> Checkedout;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|0141439513|7</td></tr><tr><td>123|0147515874|7</td></tr><tr><td>123|3958700152|7</td></tr><tr><td>125|0199539278|7</td></tr><tr><td>125|1514698854|7</td></tr><tr><td>125|1976319161|7</td></tr><tr><td>125|3958700152|7</td></tr></tbody></table>
            <p>Now each row has the total number of borrowed books for all members. We can count the number of borrowed copies for books from the <code>Checkedout</code> table without grouping the books:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, count(isbn) <b>over</b>(<b>partition</b> <b>by</b> isbn) <b>from</b> Checkedout;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|0141439513|1</td></tr><tr><td>123|0147515874|1</td></tr><tr><td>125|0199539278|1</td></tr><tr><td>125|1514698854|1</td></tr><tr><td>125|1976319161|1</td></tr><tr><td>123|3958700152|2</td></tr><tr><td>125|3958700152|2</td></tr></tbody></table>
            <p>Now ISBN 3958700152 is included twice in the results. This was not the case when using the <code><b>group</b> <b>by</b></code> clause. We were able to count the books that were more than 30 days overdue for each member, but listing the ISBNs was not possible using the <code><b>group</b> <b>by</b></code> clause. With a window function we can include the total number of overdue books for each record:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, 'Overdue count: ' || count(isbn) <b>over</b>(<b>partition</b> <b>by</b> memberid) <b>from</b> Checkedout <b>where</b> julianday('2018-04-15') - julianday(checkoutdate)&gt;30;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|3958700152|Overdue count: 1</td></tr><tr><td>125|1514698854|Overdue count: 2</td></tr><tr><td>125|3958700152|Overdue count: 2</td></tr></tbody></table>
            <p>With the <code><b>group</b> <b>by</b></code> clause we were limited to using aggregate functions. With the <code><b>over</b></code> clause we can use additional analytical functions. For example, the <code>first_value()</code> function returns the first value in an ordered set of values. For the <code>first_value()</code> function to work the records in the partition will need to be ordered using the <code><b>order</b> <b>by</b></code> clause of the window definition. This is not the same as the <code><b>order</b> <b>by</b></code> clause that we have previously seen, which was the last clause of a <code><b>select</b></code> statement. It does not guarantee the order of the rows returned by the <code><b>select</b></code> statement, and does not override the <code><b>order</b> <b>by</b></code> clause of the <code><b>select</b></code> statement. To demonstrate, we will list all books in the <code>Checkedout</code> table and include an additional column that has the checkout date for the book that has been borrowed the longest:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, checkoutdate, 'Longest borrowed: ' || first_value(checkoutdate) <b>over</b>(<b>partition</b> <b>by</b> memberid <b>order</b> <b>by</b> checkoutdate) <b>from</b> Checkedout <b>order</b> <b>by</b> isbn;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|0141439513|2018-03-21|Longest borrowed: 2018-03-01</td></tr><tr><td>123|0147515874|2018-03-19|Longest borrowed: 2018-03-01</td></tr><tr><td>125|0199539278|2018-03-18|Longest borrowed: 2018-03-05</td></tr><tr><td>125|1514698854|2018-03-05|Longest borrowed: 2018-03-05</td></tr><tr><td>125|1976319161|2018-03-18|Longest borrowed: 2018-03-05</td></tr><tr><td>123|3958700152|2018-03-01|Longest borrowed: 2018-03-01</td></tr><tr><td>125|3958700152|2018-03-05|Longest borrowed: 2018-03-05</td></tr></tbody></table>
            <p>When using a window function the <code><b>partition</b> <b>by</b></code> clause should be the first clause of the window definition, if present. The <code><b>order</b> <b>by</b></code> clause should come afterwards. The <code><b>desc</b></code> and <code><b>asc</b></code> keywords can also be used with the <code><b>order</b> <b>by</b></code> clause. In the following example we list rows in the <code>Checkedout</code> table and included a column that has the most recently borrowed book by members:</p>
            <table class="sql"><thead><tr><th>SQL statement</th></tr></thead><tbody><tr><td><code><b>select</b> memberid, isbn, checkoutdate, 'Most recently borrowed: ' || first_value(checkoutdate) <b>over</b>(<b>partition</b> <b>by</b> memberid <b>order</b> <b>by</b> checkoutdate <b>desc</b>) <b>from</b> Checkedout <b>order</b> <b>by</b> isbn;</code></td></tr></tbody></table>
            <table class="output"><thead><tr><th>Output</th></tr></thead><tbody><tr><td>123|0141439513|2018-03-21|Most recently borrowed: 2018-03-21</td></tr><tr><td>123|0147515874|2018-03-19|Most recently borrowed: 2018-03-21</td></tr><tr><td>125|0199539278|2018-03-18|Most recently borrowed: 2018-03-18</td></tr><tr><td>125|1514698854|2018-03-05|Most recently borrowed: 2018-03-18</td></tr><tr><td>125|1976319161|2018-03-18|Most recently borrowed: 2018-03-18</td></tr><tr><td>123|3958700152|2018-03-01|Most recently borrowed: 2018-03-21</td></tr><tr><td>125|3958700152|2018-03-05|Most recently borrowed: 2018-03-18</td></tr></tbody></table>
            <h3>Window function frame</h3>
            <p>The window function can be further narrowed to a subset of records within a partition using a frame. A frame is an interval within the partition. There are three frame types, defined using the keywords <code><b>rows</b></code>, <code><b>groups</b></code> and <code><b>range</b></code>. The frame type determines how the starting and ending boundaries of the frame are determined.</p>
            <p>For <code><b>rows</b></code> the starting and ending boundaries for the frame are determined by counting individual rows relative to the current row. Which rows precede and which come after the current row is determined by the <code><b>order</b> <b>by</b></code> clause of the window definition.</p>
            <p>For the <code><b>range</b></code> frame type, the boundaries are determined by comparing values against the expression specified after the <code><b>range</b></code> keyword. The window definition must have an <code><b>order</b> <b>by</b></code> clause and it must have exactly one column. The frame includes the records for which the values in that column are within the range.</p>
            <p>For <code><b>groups</b></code> the starting and ending boundaries are determine by counting "groups" relative to the current group. A "group" is a set of rows that all have the same values specified in the <code><b>order</b> <b>by</b></code> clause of the window definition.</p>
            <p>The <code><b>rows</b></code> and <code><b>groups</b></code> frame types are similar in that they both determine the extent of a frame by counting relative to the current row. The difference is that <code><b>rows</b></code> counts individual rows, while <code><b>groups</b></code> counts sets of grouped rows. The <code><b>range</b></code> frame type on the other hand determines the extent of a frame by looking for values that are within a range relative to the current row.</p>
            <p>The frame start and end can be specified using the following keywords:</p>
            <ul>
                <li><code><b>unbounded</b> <b>preceding</b></code>: The frame starts at the first row of the partition.</li>
                <li>N <code><b>preceding</b></code>: The frame starts Nth rows before the current row.</li>
                <li><code><b>current</b> <b>row</b></code>: The frame starts at the current row that is being evaluated.</li>
                <li><code><b>unbounded</b> <b>following</b></code>: The frame ends at the final row in the partition.</li>
                <li>N <code><b>following</b></code>: The frame ends at the Nth row after the current row.</li>
            </ul>
            <p>For example, to use a function on the subset of a partition between the current row and all rows preceding it, the <code><b>over</b></code> clause would look as follows:<br>
            <code><b>over</b>(<b>partition</b> <b>by</b> ... <b>order</b> <b>by</b> ... <b>rows</b> <b>between</b> <b>unbounded</b> <b>preceding</b> <b>and</b> <b>current</b> <b>row</b>)</code></p>
            <p>To use a function on the subset of a partition that consists of 3 rows before and after the current row, the <code><b>over</b></code> clause would look as follows:<br>
            <code><b>over</b>(<b>partition</b> <b>by</b> ... <b>order</b> <b>by</b> ... <b>rows</b> <b>between</b> 3 <b>preceding</b> <b>and</b> 3 <b>following</b>) 
</code></p>
            <p>It is generally best to always specify a frame in the window definition, since the default frame changes based on whether or not there is an <code><b>order</b> <b>by</b></code> clause in the window definition. If the <code><b>order</b> <b>by</b></code> clause is included in the window definition then the default frame is:<br>
            <code><b>range</b> <b>unbounded</b> <b>preceding</b> <b>and</b> <b>current</b> <b>row</b></code>
            </p><p>If there is no <code><b>order</b> <b>by</b></code> clause in the window definition, then the default frame is:<br>
            <code><b>range</b> <b>between</b> <b>unbounded</b> <b>preceding</b> <b>and</b> <b>unbounded</b> <b>following</b></code></p>
            <p>Finally, the <code><b>exclude</b></code> clause of the window function may be used to exclude rows. It can be used with the following combination of keywords:</p>
            <ul>
                <li><code><b>exclude</b> <b>no</b> <b>others</b></code>: This is the default. No rows are excluded from the window frame.</li>
                <li><code><b>exclude</b> <b>current</b> <b>row</b></code>: The current row for which the window function is being calculated is excluded from the window frame.</li>
                <li><code><b>exclude</b> <b>group</b></code>: The current row and all other rows that have the same value for the column(s) in the <code><b>order</b> <b>by</b></code> clause are excluded.</li>
                <li><code><b>exclude</b> <b>ties</b></code>: The current row is part of the frame, but all other rows that have the same value for the column(s) in the <code><b>order</b> <b>by</b></code> clause are excluded.</li>
            </ul>
            <p>Example of the <code><b>over</b></code> clause including an <code><b>exclude</b></code> clause:<br>
            <code><b>over</b>(<b>partition</b> <b>by</b> ... <b>order</b> <b>by</b> ... <b>rows</b> <b>between</b> <b>unbounded</b> <b>preceding</b> <b>and</b> <b>current</b> <b>row</b> <b>exclude</b> <b>ties</b>)
</code></p>
            <p>Note that window functions are evaluated after the data columns have been selected / retrieved from the database. Hence, window functions cannot be used as part of the <code><b>where</b></code>, <code><b>group</b> <b>by</b></code> or <code><b>having</b></code> clauses. The remainder of the chapter lists standard window functions. As always, the database that you are using may support additional function.</p>

            <h3>cume_dist() function</h3>
            <p>Calculates the cumulative distribution for the column specified in the <code><b>order</b> <b>by</b></code> clause of the window definition.</p>

            <h3>dense_rank() function</h3>
            <p>Creates a ranking based on the column specified in the <code><b>order</b> <b>by</b></code> clause of the window definition. Rows are numbered starting from 1, with identical values receiving the same rank. The numbering is always consecutive. The function returns the rank number.</p>

            <h3>first_value(<i>expression</i>) function</h3>
            <p>Returns the first value in an ordered set of values. The argument of the function does not have to be the same column as for the <code><b>order</b> <b>by</b></code> clause of the window definition.</p>

            <h3>lead(<i>expression</i>, <i>offset</i>, <i>default</i>) function</h3>
            <p>Returns the result of evaluating the expression against the previous row in the partition. If there is no previous row, then it returns <code><b>null</b></code>. The offset and default arguments are optional. The offset can be a non-negative integer. If there is an offset, then the function returns the result of evaluating expression against the row that is offset number of rows before the current row within the partition. If offset is 0, then the expression is evaluated against the current row. If default is also specified, then the default value is returned instead of <code><b>null</b></code>.</p>

            <h3>lag(<i>expression</i>, <i>offset</i>, <i>default</i>) function</h3>
            <p>Returns the result of evaluating the expression against the next row in the partition. If there is no row after, then it returns <code><b>null</b></code>. The offset and default arguments are optional. The offset can be a non-negative integer. If there is an offset, then the function returns the result of evaluating expression against the row that is offset number of rows after the current row within the partition. If offset is 0, then the expression is evaluated against the current row. If default is also specified, then the default value is returned instead of <code><b>null</b></code>.</p>

            <h3>last_value(<i>expression</i>) function</h3>
            <p>Returns the last value in an ordered set of values. The argument of the function does not have to be the same column as for the <code><b>order</b> <b>by</b></code> clause of the window definition.</p>

            <h3>ntile(<i>N</i>) function</h3>
            <p>The function takes a number as an argument, N, and divides the partition into N groups as evenly as possible and assigns an integer between 1 and N to each group. The function returns the integer value assigned to the group that the current row is a part of.</p>

            <h3>percent_rank() function</h3>
            <p>Returns a value between 0.0 and 1.0 using the following formula: (rank - 1)/(rowcnt - 1)<br>
                Where rank is the value returned by the <code>rank()</code> window function and rowcnt is the total number of rows in the partition.</p>

            <h3>rank() function</h3>
            <p>Creates a ranking based on column specified in the <code><b>order</b> <b>by</b></code> clause of the window definition. Rows are numbered starting from 1, with identical values receiving the same rank. Unlike <code>dense_rank()</code>, the numbers may not be consecutive due to identical values receiving the same rank. The function returns the rank number.</p>

            <h3>row_number() function</h3>
            <p>Returns the number of the row within the current partition. Rows are numbered starting from 1 in the order defined by the <code><b>order</b> <b>by</b></code> clause in the window definition.</p>

        </section>

        <!-- 6. Table operations -->
        <section>
            <h1>6. Table operations</h1>
            <p>In chapter 2 we saw how to create tables and indexes. The table definitions included check constraints, unique constraints, primary key and foreign key constraints, column data types and default values in order to ensure that invalid values do not make it into the database. Most databases allow for altering table definitions and constraints after creation, in addition to deleting tables and indexes. However, databases implement altering tables slightly differently (and most of these statements are not supported by SQLite.) For example, Microsoft SQL Server does not allow deletion of a column if it has a primary key or foreign key constraint, while Oracle DB allows for deletion. SQLite does not implement deletion of columns at all. Hence, this chapter is intended to be informational. You will need to consult the reference manual of the database that you are using to ensure that you are using the correct syntax and that there are no unintended consequences of the SQL statements. The following table operations are available in SQL:</p>
            <table class="sql"><thead><tr><th>Add column SQL statement</th></tr></thead><tbody><tr><td><code><b>alter</b> <b>table</b> <i>tableName</i> <b>add</b> <b>column</b> <i>columnDefinition</i>;</code></td></tr></tbody></table>
            <p>Adds a column to a table, where <i>tableName</i> should be substituted with the table name, and <i>columnDefinition</i> should be substituted with the column definition.</p>
            <table class="sql"><thead><tr><th>Add constraint SQL statement</th></tr></thead><tbody><tr><td><code><b>alter</b> <b>table</b> <i>tableName</i> <b>add</b> <b>constraint</b> <i>constraintDefinition</i>;</code></td></tr></tbody></table>
            <p>Adds a constraint to a table, where <i>tableName</i> should be substituted with the table name, and <i>constraintDefinition</i> should be substituted with the constraint definition.</p>
            <table class="sql"><thead><tr><th>Drop column SQL statement</th></tr></thead><tbody><tr><td><code><b>alter</b> <b>table</b> <i>tableName</i> <b>drop</b> <b>column</b> <i>columnName</i>;</code></td></tr></tbody></table>
            <p>Deletes a column from a table, where <i>tableName</i> should be substituted with the table name, and <i>columnName</i> should be substituted with the column name.</p>
            <table class="sql"><thead><tr><th>Drop constraint SQL statement</th></tr></thead><tbody><tr><td><code><b>alter</b> <b>table</b> <i>tableName</i> <b>drop</b> <b>constraint</b> <i>constraintName</i>;</code></td></tr></tbody></table>
            <p>Deletes an existing named constraint from a table, where <i>tableName</i> should be substituted with the table name, and <i>constraintName</i> should be substituted with the constraint name.</p>
            <table class="sql"><thead><tr><th>Drop table SQL statement</th></tr></thead><tbody><tr><td><code><b>drop</b> <i>tableName</i>;</code></td></tr></tbody></table>
            <p>Deletes a table including all records, where <i>tableName</i> should be substituted with the table name.</p>
            <table class="sql"><thead><tr><th>Drop index SQL statement</th></tr></thead><tbody><tr><td><code><b>drop</b> <i>indexName</i>;</code></td></tr></tbody></table>
            <p>Deletes a named index, where <i>indexName</i> should be substituted with the index name.</p>
            <table class="sql"><thead><tr><th>Delete records SQL statement</th></tr></thead><tbody><tr><td><code><b>delete</b> <b>from</b> <i>tableName</i> <b>where</b> <i>expression</i>;</code></td></tr></tbody></table>
            <p>Deletes records from a table that match the <code><b>where</b></code> clause of the statement, where <i>tableName</i> should be substituted with the table name, and <i>expression</i> should be substituted with a comparison expression.</p>
            <table class="sql"><thead><tr><th>Truncate SQL statement</th></tr></thead><tbody><tr><td><code><b>truncate</b> <i>tableName</i>;</code></td></tr></tbody></table>
            <p>Deletes all records from a table, where <i>tableName</i> should be substituted with the table name.</p>
            <table class="sql"><thead><tr><th>Create table using select SQL statement</th></tr></thead><tbody><tr><td><code><b>create</b> <b>table</b> <i>tableName</i> <b>as</b> (<i>selectStatement</i>);</code></td></tr></tbody></table>
            <p>Creates a new table by copying the columns from an existing table or tables, where <i>tableName</i> should be substituted with the name of the table to be created, and <i>selectStatement</i> should be substituted by a <code><b>select</b></code> statement that returns the columns to be added from existing table(s).</p>
        </section>

</body></html>
